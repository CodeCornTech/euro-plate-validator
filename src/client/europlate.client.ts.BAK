// src/client/europlate.client.ts
// Minimal client SDK (mask + validate + UI opzionale) ‚Äî dependency-light
// Usa IM UMD su window.Inputmask (injectabile), nessun hardcode di DOM/paesi.
import type { CountryKey } from "../countries.js";
import {
  FLAG_MAP,
  COUNTRY_NAMES,
  supportedCountries,
  normalizeCode,
  getCountryName,
} from "../countries.js";

type Lang = "it" | "en";
export type I18nCode = "AUTO" | "IT" | "EN";

export type VehicleType = "any" | "car" | "bike";
export type Logger = {
  debug?: (...a: any[]) => void;
  info?: (...a: any[]) => void;
  warn?: (...a: any[]) => void;
  error?: (...a: any[]) => void;
  notify?: (msg: string, type?: string) => void;
};

export type EuroPlateUI = {
  flagIcon?: HTMLElement;
  flagLabel?: HTMLElement;
  dropdown?: HTMLElement;
  button?: HTMLElement;
  status?: HTMLElement;
};

export type EuroPlateOptions = {
  input: HTMLInputElement; // REQUIRED
  ui?: EuroPlateUI; // opzionale (UI pronta)
  allowedCountries?: string[]; // default: tutte
  mode?: "AUTO" | string; // default: "AUTO"
  vehicleType?: VehicleType; // default: "any"
  placeholders?: { auto?: string }; // default: "AA 999 AA / AA-999-AA / 9999 AAA"
  normalize?: (code: string) => string; // default: GB->UK
  formatters?: Record<string, (s: string) => string>; // per-CC
  timings?: { debounce?: number; clear?: number }; // default: 80/60
  logger?: Logger; // opzionale
  deps?: { inputmask?: any }; // opzionale (se non c‚Äô√® su window)
  debug?: boolean; // default: false
  i18n?: I18nCode; // <‚Äî NEW (default: 'AUTO')
};

const ALL_COUNTRIES = supportedCountries as readonly CountryKey[];

function isCountryKey(x: string): x is CountryKey {
  return (ALL_COUNTRIES as readonly string[]).includes(x);
}

// üëá chiavi scalari (niente 'countries')
type DictScalarKey = "auto" | "placeholderAuto" | "valid" | "invalid" | "checked";

// Nomi paese localizzati (facoltativi per ciascun cc)
type CountryNameDict = Partial<Record<CountryKey, string>>;

const DICT: Record<
  Lang,
  {
    auto: string;
    placeholderAuto: string;
    valid: string;
    invalid: string;
    checked: string;
    countries: CountryNameDict;
  }
> = {
  it: {
    auto: "Auto (Tutti)",
    placeholderAuto: "AA 999 AA / AA-999-AA / 9999 AAA",
    valid: "Valida",
    invalid: "Non valida",
    checked: "Controllati",
    countries: { IT: "Italia", FR: "Francia", DE: "Germania", ES: "Spagna", NL: "Paesi Bassi" },
  },
  en: {
    auto: "Auto (All)",
    placeholderAuto: "AA 999 AA / AA-999-AA / 9999 AAA",
    valid: "Valid",
    invalid: "Invalid",
    checked: "Checked",
    countries: { IT: "Italy", FR: "France", DE: "Germany", ES: "Spain", NL: "Netherlands" },
  },
};
function pickLang(code: I18nCode): Lang {
  if (code === "IT") return "it";
  if (code === "EN") return "en";
  const nav = (navigator?.language || "").toLowerCase();
  return nav.startsWith("it") ? "it" : "en";
}

// ‚úÖ ora t() restituisce sempre string
function t(lang: Lang, key: DictScalarKey): string {
  return DICT[lang][key];
}

// ‚úÖ countryName legge prima i18n, poi fallback EN/core
function countryName(lang: Lang, cc: string): string {
  const norm = normalizeCode(cc) as CountryKey | undefined;
  if (!norm) return cc.toUpperCase();
  const local = DICT[lang].countries?.[norm];
  if (local) return local;
  return getCountryName(norm) ?? COUNTRY_NAMES[norm] ?? norm;
}

export type EuroPlateInstance = {
  setCountry: (code: "AUTO" | string) => void;
  setAllowed: (codes: string[]) => void;
  setVehicleType: (t: VehicleType) => void;
  setDebug: (on: boolean) => void;
  setMode: (m: "AUTO" | string) => void; // üëà aggiunto
  setI18n: (code: I18nCode) => void; // üëà mancava
  validate: () => { ok: boolean; country?: string; value: string };
  destroy: () => void;
  getI18n: () => Lang;
};

export function createEuroPlate(EuroMod: any, opts: EuroPlateOptions): EuroPlateInstance {
  const {
    i18n = "AUTO",
    input,
    ui = {},
    allowedCountries,
    mode = "AUTO",
    vehicleType = "any",
    placeholders = { auto: "AA 999 AA / AA-999-AA / 9999 AAA" },
    normalize = (c: string) =>
      String(c || "").toUpperCase() === "GB" ? "UK" : String(c || "").toUpperCase(),
    formatters = {
      FR: (s: string) => s.toUpperCase().replace(/\s+/g, "-"),
      IT: (s: string) => s.toUpperCase().replace(/\s+/g, " "),
      ES: (s: string) => s.toUpperCase().replace(/[-_]+/g, " "),
    },
    timings = { debounce: 80, clear: 60 },
    logger,
    deps,
    debug = false,
  } = opts || ({} as EuroPlateOptions);
  let lang: Lang = pickLang(opts?.i18n ?? "AUTO");
  //  const lang: Lang = pickLang(opts?.i18n ?? "AUTO");
  const button = ui.button ?? undefined;
  const dropdown = ui.dropdown ?? undefined;
  const flagIcon = ui.flagIcon ?? undefined;
  const flagLabel = ui.flagLabel ?? undefined;
  const statusEl = ui.status ?? undefined;

  if (!EuroMod?.validatePlate || !EuroMod?.getInputMask) {
    throw new Error("EuroMod mancante o incompleto");
  }
  if (!input) throw new Error("opts.input √® richiesto");

  // logger morbido
  let DBG = !!debug;
  const log: Logger = {
    debug: (...a) => {
      if (DBG) (logger?.debug ?? console.debug)("[EPL]", ...a);
    },
    info: (...a) => {
      if (DBG) (logger?.info ?? console.info)("[EPL]", ...a);
    },
    warn: (...a) => {
      if (DBG) (logger?.warn ?? console.warn)("[EPL]", ...a);
    },
    error: (...a) => {
      if (DBG) (logger?.error ?? console.error)("[EPL]", ...a);
    },
    notify: (msg, type = "info") => {
      if (DBG) (logger?.notify ?? (() => {}))(msg, type);
    },
  };

  const IM = deps?.inputmask ?? (globalThis as any).Inputmask;
  if (!IM) log.warn?.("Inputmask non trovato: la maschera non sar√† applicata");

  const {
    supportedCountries,
    getInputMask,
    getDisplayFormat,
    COUNTRY_NAMES,
    FLAG_MAP,
    validatePlate,
  } = EuroMod;

  let selected: "AUTO" | CountryKey = (() => {
    if (mode === "AUTO") return "AUTO";
    const n = normalize(String(mode || ""));
    return isCountryKey(n) ? (n as CountryKey) : "AUTO";
  })();
  let allowed =
    allowedCountries && allowedCountries.length ? allowedCountries : [...supportedCountries];
    
  let destroyed = false;

  const fmtFor = (cc: string, s: string) =>
    formatters[cc] ? formatters[cc](s) : String(s).toUpperCase();

  // setFlag
  const setFlag = (
    code: "AUTO" | CountryKey | null,
    flagIcon: HTMLElement | undefined,
    flagLabel: HTMLElement | undefined,
    lang: Lang
  ) => {
    if (!flagIcon || !flagLabel) return; // UI opzionale
    if (!code || code === "AUTO") {
      flagIcon.className = "iti__flag iti__auto-eu";
      flagLabel.textContent = t(lang, "auto");
      return;
    }
    const iso = FLAG_MAP[code] || "auto-eu";
    flagIcon.className = `iti__flag iti__${iso}`;
    flagLabel.textContent = `${countryName(lang, code)} (${code})`; // sempre string
  };

  const debounce = <T extends (...args: any[]) => any>(fn: T, wait = 80) => {
    let t: any;
    return (...args: Parameters<T>) => {
      clearTimeout(t);
      t = setTimeout(() => fn(...args), wait);
    };
  };

  function hardClearMask(el?: HTMLInputElement | null) {
    if (!el || !IM) return;
    setTimeout(() => {
      try {
        (el as any)._imInstance?.remove?.();
      } catch {}
      try {
        (el as any).inputmask?.remove?.();
      } catch {}
      (el as any)._imInstance = null;
    }, 0);
    log.debug?.("mask:clear (hard)");
  }
  const hardClearMaskDebounced = debounce(hardClearMask, timings.clear);

  const normalizePattern = (p: string) =>
    String(p)
      .replace(/A\{(\d+)\}/g, (_, n) => "A".repeat(+n))
      .replace(/9\{(\d+)\}/g, (_, n) => "9".repeat(+n));

  const applyMaskDebounced = debounce((inputEl: HTMLInputElement, country: string) => {
    if (!IM) return;
    if (!inputEl || !country || country === "AUTO") {
      hardClearMaskDebounced(inputEl);
      return;
    }
    const spec = getInputMask(country);
    if (!spec) {
      hardClearMaskDebounced(inputEl);
      return;
    }

    const opts = {
      mask: normalizePattern(spec.mask),
      keepStatic: spec.keepStatic ?? true,
      greedy: spec.greedy ?? false,
      placeholder: "",
      showMaskOnHover: false,
      showMaskOnFocus: false,
      jitMasking: true,
      autoUnmask: false,
      insertModeVisual: false,
      rightAlign: false,
      definitions: spec.definitions || {
        A: { validator: "[A-Z]", casing: "upper" },
        H: { validator: "[A-HJ-NP-RTV-Z]", casing: "upper" },
        9: { validator: "[0-9]" },
      },
      onBeforeMask: (v: string) => fmtFor(country, String(v ?? "")),
      onBeforePaste: (p: string) => fmtFor(country, String(p ?? "")),
      positionCaretOnClick: "lvp",
    };

    try {
      (inputEl as any)._imInstance?.remove?.();
      (inputEl as any).inputmask?.remove?.();
    } catch {}

    let instance: any;
    try {
      instance = IM(opts);
    } catch {
      instance = new IM(opts);
    }
    instance.mask(inputEl);
    (inputEl as any)._imInstance = instance;
    log.debug?.("mask:apply", country, opts.mask);
  }, timings.debounce);

  // setValidityUI
  function setValidityUI(
    ok: boolean,
    msg: string,
    matchCountry: CountryKey | null,
    input: HTMLInputElement,
    status: HTMLElement | undefined,
    lang: Lang
  ) {
    input.classList.toggle("valid", !!ok);
    input.classList.toggle("invalid", !ok);
    input.setAttribute("aria-invalid", ok ? "false" : "true");
    input.setCustomValidity(ok ? "" : msg || "Invalid plate");

    if (!status) return;

    if (ok && matchCountry) {
      status.className = "status ok";
      status.textContent = `‚úÖ ${t(lang, "valid")} ‚Äî ${countryName(lang, matchCountry)} (${matchCountry})`;
    } else if (!ok) {
      status.className = "status err";
      status.textContent = msg || `‚ùå ${t(lang, "invalid")}`;
    } else {
      status.className = "status";
      status.textContent = "";
    }
  }

  // renderDropdown
  function renderDropdown() {
    if (!dropdown) return;
    const frag = document.createDocumentFragment();

    // AUTO
    {
      const auto = document.createElement("div");
      auto.className = "country-item";
      auto.role = "option";
      auto.dataset.value = "AUTO";
      auto.innerHTML = `
      <div class="iti__flag-box"><div class="iti__flag iti__auto-eu"></div></div>
      <div class="country-name">${t(lang, "auto")}</div>
      <div class="country-code">ANY</div>`;
      auto.onclick = () => selectCountry("AUTO");
      frag.appendChild(auto);
    }

    // paesi whitelisted
    for (const c of allowed) {
      const n = normalize(String(c || ""));
      if (!isCountryKey(n)) continue;

      const iso = FLAG_MAP?.[n] || "auto-eu";
      const div = document.createElement("div");
      div.className = "country-item";
      div.role = "option";
      div.dataset.value = n;
      div.innerHTML = `
      <div class="iti__flag-box"><div class="iti__flag iti__${iso}"></div></div>
      <div class="country-name">${countryName(lang, n)}</div>
      <div class="country-code">${n}</div>`;
      div.onclick = () => selectCountry(n);
      frag.appendChild(div);
    }

    dropdown.innerHTML = "";
    dropdown.appendChild(frag);
  }

  function validateNow() {
    if (destroyed) return { ok: false, value: input.value };

    let raw = input.value;

    if (!raw.trim()) {
      setValidityUI(false, "", null, input, statusEl, lang);

      if (selected === "AUTO") {
        hardClearMaskDebounced(input);
        input.placeholder = placeholders.auto || "";
      }
      return { ok: false, value: raw };
    }

    if (selected !== "AUTO") {
      const formatted = fmtFor(selected, raw);
      if (formatted !== raw) {
        const caret = input.selectionStart;
        input.value = formatted;
        if (caret != null) input.setSelectionRange(caret, caret);
        raw = formatted;
      }
    } else {
      const v2 = raw.toUpperCase().replace(/\s+/g, " ").trimStart();
      if (v2 !== raw) input.value = raw = v2;
    }

    const countries = selected === "AUTO" ? allowed : [selected];
    const res = validatePlate(raw, countries, { vehicleType });

    if (res.isValid && res.matches.length) {
      const match = normalize(res.matches[0]?.country || "");
      const formatted = fmtFor(match, input.value);
      if (formatted !== input.value) input.value = formatted;

      setValidityUI(true, "", match as CountryKey, input, statusEl, lang);
      setFlag(match as CountryKey, flagIcon, flagLabel, lang);
      applyMaskDebounced(input, match);

      const fmt = getDisplayFormat(match);
      if (fmt) input.placeholder = fmt;

      return { ok: true, country: match, value: input.value };
    } else {
      // KO
      const checkedArr = res.checked ?? [];
      const msg = checkedArr.length
        ? `‚ùå ${t(lang, "invalid")} ‚Äî ${t(lang, "checked")}: ${checkedArr.join(", ")}`
        : `‚ùå ${t(lang, "invalid")}`;

      setValidityUI(false, msg, null, input, statusEl, lang);

      // In AUTO rimuovi eventuale mask ‚Äúresidua‚Äù
      if (selected === "AUTO") {
        hardClearMaskDebounced(input);
        input.placeholder = "";
      }

      return { ok: false, value: input.value };
    }
  }

  function updatePlaceholderForCurrentSelection(
    selected: "AUTO" | CountryKey,
    input: HTMLInputElement,
    EuroMod: any,
    lang: Lang
  ) {
    if (selected === "AUTO") {
      input.placeholder = t(lang, "placeholderAuto");
    } else {
      input.placeholder = EuroMod.getDisplayFormat(selected) || "";
    }
  }

  // hasBtnDrop
  function hasBtnDrop(b?: HTMLElement, d?: HTMLElement): b is HTMLElement & {} {
    return !!b && !!d;
  }

  // onDocClick
  const onDocClick = (e: MouseEvent) => {
    if (!dropdown || !button) return;
    const t = e.target as Node;
    if (!dropdown.contains(t) && !button.contains(t)) {
      dropdown.classList.remove("open");
      button.setAttribute("aria-expanded", "false");
    }
  };

  function selectCountry(code: "AUTO" | string) {
    // normalizza/valida
    let next: "AUTO" | CountryKey = "AUTO";
    if (code !== "AUTO") {
      const n = normalize(String(code || ""));
      if (isCountryKey(n)) next = n;
      else next = "AUTO";
    }
    selected = next;

    // flag + placeholder
    setFlag(selected, flagIcon, flagLabel, lang);
    updatePlaceholderForCurrentSelection(selected, input, EuroMod, lang);

    // mask
    if (selected === "AUTO") {
      hardClearMaskDebounced(input);
    } else {
      const v = fmtFor(selected, input.value);
      if (input.value !== v) input.value = v;
      applyMaskDebounced(input, selected);
    }

    // chiudi dropdown
    if (dropdown && button) {
      dropdown.classList.remove("open");
      button.setAttribute("aria-expanded", "false");
    }

    input.focus();
  }

  const instance: EuroPlateInstance = {
    setCountry: (code) => selectCountry(code),

    setAllowed(codes) {
      allowed = Array.from(new Set((codes || []).map(normalize)));
      renderDropdown();
    },
    setVehicleType(t) {
      (opts as any).vehicleType = t;
    },
    setDebug(on) {
      DBG = !!on;
    },

    // üëá AGGIUNGI QUESTO (ti mancava nel type)
    setMode(m: "AUTO" | string) {
      selectCountry(m);
    },

    setI18n(code) {
      lang = pickLang(code);
      renderDropdown();
      setFlag(selected, flagIcon, flagLabel, lang);
      updatePlaceholderForCurrentSelection(selected, input, EuroMod, lang);
    },
    validate: validateNow,
    destroy() {
      destroyed = true;
      hardClearMaskDebounced(input);
      input.removeEventListener("input", validateNow as any);
      input.removeEventListener("blur", validateNow as any);
      document.removeEventListener("click", onDocClick);
    },
    getI18n: () => lang,
  };

  // wiring eventi
  if (button) {
    button.addEventListener("click", () => {
      if (!dropdown) return;
      const open = dropdown.classList.toggle("open");
      button.setAttribute("aria-expanded", open ? "true" : "false");
    });
  }

  document.addEventListener("click", onDocClick);
  input.addEventListener("input", validateNow as any);
  input.addEventListener("blur", validateNow as any);

  renderDropdown();
  //instance.setCountry(selected);
  selectCountry(mode); // invece di instance.setCountry(selected) con parametri mancanti
  log.notify?.("EuroPlate pronto ‚úÖ", "success");

  return instance;
}
